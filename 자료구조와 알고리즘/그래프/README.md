## 그래프

**비선형 자료구조** 중 하나로, **네트워크(*Network*)**라고 부르기도 한다.

### 개념과 용어

 * 그래프는 어떠한 값을 가지고 있는 **노드(*Node*)**(**정점(*Vertex*)**)과, 두 개의 노드을 잇는 **간선(*Edge*)**으로 구성되어 있다.
 * 그러나 모든 노드가 서로 연결되어 있지 않을 수 있다. 모든 노드가 다른 모든 노드를 방문할 수 있는, 다시 말해 한 덩어리로 구성된 그래프를 **연결 그래프(*Connected Graph*)**, 그렇지 않은 그래프는 **비연결 그래프(*Disconnected Graph*)**라고 부른다.
 * 간선은 **방향**을 가질 수도 있다. 방향이 있는 간선이 사용되는 그래프를 **방향 그래프(*Directed Graph*)**, 방향이 없는 간선이 사용되는 그래프를 **무방향 그래프(*Undirected Graph*)**라고 부른다.
 * 간선은 비용이나 거리를 나타내는 **가중치**를 가질 수도 있다. 가중치가 있는 간선이 사용되는 그래프를 **가중치 그래프(*Weighted Graph*)**라고 부른다.
 * 모든 노드가 서로 연결되어 있는 그래프를 **완전 그래프(*Complete Graph*)**라고 부르며, 무방향 완전 그래프의 간선 수는 `n(n-1)/2`이다.
 * 관련 용어
   * **인접 노드(*Adjacent node*)**: 자신과 직접 연결된 노드
   * **차수(*Degree*)**: 무방향 그래프에서 한 노드의 인접 노드 수
     * 무방향 그래프의 **모든 노드의 차수의 합은 간선 수의 2배와 같다.**
   * **진입/진출 차수(*In/Out-degree*)**: 방향 그래프에서 자신에게 들어오는/자신에게서 나오는 간선의 수
   * **단순 경로(*Simple path*)**: 경로에 반복되는 노드가 없는 경우
   * **사이클(*Cycle*)**: 단순 경로의 시작과 끝이 동일한 경우
   * **오일러 경로(*Eulerian tour*)**: 그래프에 존재하는 모든 간선을 한 번만 통과하면서 출발한 노드로 돌아오는 경로
     * 모든 노드에 대해 연결된 간선 수가 짝수인 경우에만 가능하다.

**트리도 그래프의 일종이다.** 트리는 일반 그래프와 달리 루트 노드와 부모/자식 노드라는 개념을 가진 사이클이 없는 연결 그래프이다.

### 구현 방식

그래프는 **인접 리스트**나 **인접 행렬**로 구현한다. 그래프에 있는 간선의 수에 따라 **간선이 적은 경우에는 인접 리스트, 많은 경우에는 인접 행렬로 구현하는 것이 좋다.**

```c++
struct node{
    int num;
    vector<node*> edge;
    vector<int> weight;	// 필요 시
}

node graph[10];
```

**인접 리스트**는 각각의 노드를 연결 그래프처럼 만들어 포인터로 연결한 것으로, 각 노드는 자신에게서 뻗는 간선 정보를 같이 저장한다(무방향 그래프의 경우 두 노드에 각각 간선 정보가 저장된다). 트리와 달리 모든 노드에 접근할 수 있는 '루트 노드'라는 개념이 없기 때문에, 모든 노드를 저장하는 별도의 배열을 만들 필요가 있다.

```c++
int graph[10][10];
```

**인접 행렬**은 각각의 노드의 연결 현황(간선)을 2차원 배열에 저장한 것이다. 노드를 생성하고 연결할 필요 없이 간단하게 구현할 수 있지만, 항상 `n^2`만큼의 공간이 필요하므로 그래프에 간선이 없는 편이라면 공간 낭비가 심해지는 단점이 있다. 또한 순회 과정에서 간선이 없는 노드들도 모두 순회해야 하기에 효율성 면에서도 인접 행렬이 불리하다.

### 순회

그래프의 모든 노드를 한 번씩 방문하는 것으로, 기본적으로 연결 그래프여야 가능하다.

그래프 순회 과정에서 같은 노드를 두 번 이상 방문할 수 없으며, 이에 대한 처리는 `visit` 배열로 한다.

#### 깊이 우선 탐색(*Depth-First Search*)

시작 노드에서 한 방향으로 갈 수 있을 만큼 방문하다가, 더 이상 진행할 수 없으면 경로를 따라 되돌아오면서 갈림길이 있는 노드의 다른 간선 방향으로 탐색을 진행한다.

이 과정에서는 **재귀, 즉 스택**이 사용된다. 구현은 다음과 같다.

```c++
node graph[10];
bool visit[10];

void dfs(int n){
	cout << n << ' ';
	for (node* p : graph[n].edge){
		if (!visit[p->num]){
			visit[p->num] = true;
			dfs(p->num);
		}
	}
}

int main(){
	// 그래프 초기화 과정 생략
	visit[0] = true;
	dfs(0);
}
```

#### 너비 우선 탐색(*Breadth-First Search*)

시작 노드에서 뻗은 모든 간선의 노드를 방문한 후, 방문한 노드에서 뻗은 간선의 노드 차례로 반복하는 과정을 반복한다.

이 과정에서는 **큐**가 사용된다. 구현은 다음과 같다.

```c++
node graph[10];
bool visit[10];

void bfs(int n){
	queue<int> q;
	q.push(n);
	visit[n] = true;
	while(!q.empty()){
		int i = q.front();
		q.pop();
		cout << i << ' ';
		for (node* p : graph[n].edge){
			if (!visit[p->num]){
				visit[p->num] = true;
				q.push(p->num);
			}
		}
	}
}
```

### 최소 신장 트리(*Minimum Spanning Tree*)

**신장 트리(*Spanning Tree*)** 는 그래프에서 **`노드 개수 - 1`개의 간선을 선택하여 만들어지는 트리**(사이클 없는 그래프)이다. 신장 트리는 그래프 순회를 통해 만들 수 있다.

**최소 신장 트리(*Minimum Spanning Tree*)** 는 신장 트리에서 사용된 **간선의 가중치 합이 가장 작은** 신장 트리이다. 즉, 가중치가 없는 트리에서는 MST 개념이 존재하지 않는다.

#### 크루스칼 알고리즘(*Kruskal Algorithm*)

#### 프림 알고리즘(*Prim Algorithm*)


### 그래프에서의 최단 경로 탐색

가중치가 없는 그래프에서 두 노드 간의 최단 경로는 **BFS**로 구할 수 있다. 그러나 가중치가 있는 그래프에서는 아래 알고리즘을 통해 구해야 한다.

#### 다익스트라 알고리즘(*Dijkstra Algorithm*)

#### 벨만-포드 알고리즘(*Bellman-Ford Algorithm*)

#### 모든 쌍 최단 경로 알고리즘(*All-pairs Shortest Path Algorithm*)

