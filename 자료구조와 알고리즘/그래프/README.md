## 그래프

**비선형 자료구조** 중 하나로, **네트워크(*Network*)** 라고 부르기도 한다.

### 개념과 용어

 * 그래프는 어떠한 값을 가지고 있는 **노드(*Node*)**(**정점(*Vertex*)**)과, 두 개의 노드을 잇는 **간선(*Edge*)** 으로 구성되어 있다.
 * 그러나 모든 노드가 서로 연결되어 있지 않을 수 있다. 모든 노드가 다른 모든 노드를 방문할 수 있는, 다시 말해 한 덩어리로 구성된 그래프를 **연결 그래프(*Connected Graph*)**, 그렇지 않은 그래프는 **비연결 그래프(*Disconnected Graph*)** 라고 부른다.
 * 간선은 **방향**을 가질 수도 있다. 방향이 있는 간선이 사용되는 그래프를 **방향 그래프(*Directed Graph*)**, 방향이 없는 간선이 사용되는 그래프를 **무방향 그래프(*Undirected Graph*)** 라고 부른다.
 * 간선은 비용이나 거리를 나타내는 **가중치** 를 가질 수도 있다. 가중치가 있는 간선이 사용되는 그래프를 **가중치 그래프(*Weighted Graph*)** 라고 부른다.
 * 모든 노드가 서로 연결되어 있는 그래프를 **완전 그래프(*Complete Graph*)** 라고 부르며, 무방향 완전 그래프의 간선 수는 `n(n-1)/2`이다.
 * 관련 용어
   * **인접 노드(*Adjacent node*)**: 자신과 직접 연결된 노드
   * **차수(*Degree*)**: 무방향 그래프에서 한 노드의 인접 노드 수
     * 무방향 그래프의 **모든 노드의 차수의 합은 간선 수의 2배와 같다.**
   * **진입/진출 차수(*In/Out-degree*)**: 방향 그래프에서 자신에게 들어오는/자신에게서 나오는 간선의 수
   * **단순 경로(*Simple path*)**: 경로에 반복되는 노드가 없는 경우
   * **사이클(*Cycle*)**: 단순 경로의 시작과 끝이 동일한 경우
   * **오일러 경로(*Eulerian tour*)**: 그래프에 존재하는 모든 간선을 한 번만 통과하면서 출발한 노드로 돌아오는 경로
     * 모든 노드에 대해 연결된 간선 수가 짝수인 경우에만 가능하다.

**트리도 그래프의 일종이다.** 트리는 일반 그래프와 달리 루트 노드와 부모/자식 노드라는 개념을 가진 사이클이 없는 연결 그래프이다.

### 구현 방식

그래프는 **인접 리스트** 나 **인접 행렬** 로 구현한다. 그래프에 있는 간선의 수에 따라 **간선이 적은 경우에는 인접 리스트, 많은 경우에는 인접 행렬로 구현하는 것이 좋다.**

```c++
struct node{
    int num;
    vector<node*> edge;
    vector<int> weight;	// 필요 시
}

node graph[10];
```

**인접 리스트** 는 각각의 노드를 연결 그래프처럼 만들어 포인터로 연결한 것으로, 각 노드는 자신에게서 뻗는 간선 정보를 같이 저장한다(무방향 그래프의 경우 두 노드에 각각 간선 정보가 저장된다). 트리와 달리 모든 노드에 접근할 수 있는 '루트 노드'라는 개념이 없기 때문에, 모든 노드를 저장하는 별도의 배열을 만들 필요가 있다.

```c++
int graph[10][10];
```

**인접 행렬** 은 각각의 노드의 연결 현황(간선)을 2차원 배열에 저장한 것이다. 노드를 생성하고 연결할 필요 없이 간단하게 구현할 수 있지만, 항상 `n^2`만큼의 공간이 필요하므로 그래프에 간선이 없는 편이라면 공간 낭비가 심해지는 단점이 있다. 또한 순회 과정에서 간선이 없는 노드들도 모두 순회해야 하기에 효율성 면에서도 인접 행렬이 불리하다.

### 순회

그래프의 모든 노드를 한 번씩 방문하는 것으로, 기본적으로 연결 그래프여야 가능하다.

그래프 순회 과정에서 같은 노드를 두 번 이상 방문할 수 없으며, 이에 대한 처리는 `visit` 배열로 한다.

#### 깊이 우선 탐색(*Depth-First Search*)

시작 노드에서 한 방향으로 갈 수 있을 만큼 방문하다가, 더 이상 진행할 수 없으면 경로를 따라 되돌아오면서 갈림길이 있는 노드의 다른 간선 방향으로 탐색을 진행한다.

이 과정에서는 **재귀, 즉 스택** 이 사용된다. 구현은 다음과 같다.

```c++
node graph[10];
bool visit[10];

void dfs(int n){
	cout << n << ' ';
	for (node* p : graph[n].edge){
		if (!visit[p->num]){
			visit[p->num] = true;
			dfs(p->num);
		}
	}
}

int main(){
	// 그래프 초기화 과정 생략
	visit[0] = true;
	dfs(0);
}
```

#### 너비 우선 탐색(*Breadth-First Search*)

시작 노드에서 뻗은 모든 간선의 노드를 방문한 후, 방문한 노드에서 뻗은 간선의 노드 차례로 반복하는 과정을 반복한다.

이 과정에서는 **큐** 가 사용된다. 구현은 다음과 같다.

```c++
node graph[10];
bool visit[10];

void bfs(int n){
	queue<int> q;
	q.push(n);
	visit[n] = true;
	while(!q.empty()){
		int i = q.front();
		q.pop();
		cout << i << ' ';
		for (node* p : graph[n].edge){
			if (!visit[p->num]){
				visit[p->num] = true;
				q.push(p->num);
			}
		}
	}
}
```

### 최소 신장 트리(*Minimum Spanning Tree*)

**신장 트리(*Spanning Tree*)** 는 그래프에서 **`노드 개수 - 1`개의 간선을 선택하여 만들어지는 트리**(사이클 없는 그래프)이다. 신장 트리는 그래프 순회를 통해 만들 수 있다.

**최소 신장 트리(*Minimum Spanning Tree*)** 는 신장 트리에서 사용된 **간선의 가중치 합이 가장 작은** 신장 트리이다. 즉, 가중치가 없는 트리에서는 MST 개념이 존재하지 않는다.

MST를 찾기 위해서 **그리디 알고리즘** (미래를 고려하지 않고 현재 상황에서 최상의 결과를 도출) 기반의 다음 두 알고리즘을 사용한다.

#### 크루스칼 알고리즘(*Kruskal Algorithm*)

> 1. 그래프의 모든 간선을 가중치 순으로 정렬한다.
> 2. 가장 작은 간선부터 차례로 선택하여 트리에 삽입한다. 이때 추가할 간선에 의해 사이클이 발생한다면 해당 간선을 버린다.
> 3. `2.`의 과정을 선택한 간선의 수가 `노드 개수 - 1`개가 될 때까지 반복한다.

위 과정에서 사이클 여부 검출을 위해 ***Union-Find* 알고리즘**을 사용한다.

> 1. 각 노드와 노드가 속한 집합 번호를 저장한 배열을 만든다(초기값은 `p[i] = i`)
> 2. 서로 다른 집합에 속한 두 노드가 연결된 경우(*union*), 두 노드의 집합 번호 중 작은 집합 번호로 두 노드의 집합 번호를 갱신한다(*find*). 이를 위해 두 가지 함수를 사용할 수 있다.
>> `union(a, b)`: 두 노드의 집합 번호를 구한 후(*find*), 두 집합을 하나로 합친다.
>> 
>> `find(i)`: `p[i] == i`가 될 때까지 재귀함수를 타고 올라가며, 그 과정에서 만나는 모든 `p[i]`를 `i`로 갱신한다.

간선을 선택할 때 **선택한 간선의 노드들의 집합 번호가 같은 경우** 사이클이 발생한다. 따라서 이 경우에는 선택한 간선을 버려야 한다.

간선의 개수에 따라 소요 시간이 결정되기 때문에(간선 n개를 정렬하므로 정렬 알고리즘에 따라 시간복잡도 결정), 간선이 적은 그래프에 유리한 알고리즘이다.

#### 프림 알고리즘(*Prim's Algorithm*)

> 1. 임의의 노드를 선택하고, 이를 MST 노드 집합에 추가한다.
> 2. MST 노드 집합에 연결된 간선 중 MST 노드 집합에 연결되지 않은 가장 작은 간선을 선택해 연결한다.
> 3. `2.`의 과정을 MST 노드 집합의 크기가 `노드 개수`가 될 때까지(= 간선의 수가 `노드 개수 - 1`개가 될 때까지) 반복한다.

크루스칼 알고리즘과 달리 노드에서 간선을 선택하기 때문에 사이클이 일어나는지 확인할 필요가 없다. 그러나 최소 거리를 찾는 과정에서 사용하는 자료구조에 따라 성능이 달라지게 된다. 만약 대상 간선들을 **최소 힙**에 넣는다면 일반 배열에 넣었을 때 대비 효율이 더 좋을 것이다. 또는, 각 노드에 도달하는 최소 길이 정보를 별도의 배열에 담아 `2.` 수행 과정에서 갱신하여 선택에 활용할 수도 있다.

### 그래프에서의 최단 경로 탐색

가중치가 없는 그래프에서 두 노드 간의 최단 경로는 **BFS**로 구할 수 있다. 그러나 가중치가 있는 그래프에서는 아래 알고리즘을 통해 구해야 한다.

#### 다익스트라 알고리즘(*Dijkstra Algorithm*)

**DP**를 활용한 최단 경로 탐색 알고리즘. 하나의 노드에서 다른 노드로 가는 모든 최소 경로를 찾아낸다. 단, 이 알고리즘에서는 **음의 가중치를 가진 간선을 사용할 수 없다.**

> 1. 모든 노드의 최단 거리를 표시하는 배열을 만들고, 시작 노드는 `0`, 나머지는 `INF`로 초기화한다.
> 2. 시작 노드와 연결된 모든 노드의 최단 거리를 연결된 간선의 가중치로 갱신한다.
> 3. 아직 방문하지 않은 노드 중 가장 거리가 짧은 노드를 선택해 이동한다.
> 4. 해당 노드에 연결된 노드 중 거리가 `INF`였던 노드의 거리는 해당 간선의 거리로 기록한다. 그렇지 않은 노드 중 `자신의 거리 + 간선의 거리 < 기록된 거리`일 경우 값을 `자신의 거리 + 간선의 거리`로 갱신한다.
> 5. `3~4.`의 과정을 가능한 모든 노드를 방문할 때까지 반복한다.

`3.`의 과정에서 '가장 거리가 짧은 노드'를 찾는 과정에는 **힙**이 활용된다.

이 과정을 네트워크가 아닌 실생활(좌표계)에서 활용할 수 있도록 개선한 알고리즘이 **A * 알고리즘**이다.

#### 벨만-포드 알고리즘(*Bellman-Ford Algorithm*)

이 알고리즘 역시 **DP**를 이용해 하나의 노드에서 다른 노드로 가는 모든 최소 경로를 찾아내지만, 다익스트라 알고리즘과 달리 **음의 가중치를 가진 간선도 사용할 수 있다.**

> 1. 모든 노드의 최단 거리를 표시하는 배열을 만들고, 시작 노드는 `0`, 나머지는 `INF`로 초기화한다.
> 2. 모든 간선을 순회하며 `출발 노드의 최단 거리 + 간선 가중치 < 도착 노드의 최단 거리`일 경우 도착 노드의 최단 거리를 `출발 노드의 최단 거리 + 간선 가중치`로 갱신한다. 출발 노드의 최단 거리가  `INF`인 경우에는 무시한다.
> 3. 이 과정을 `노드 수 - 1`만큼 반복한다. 그 전에 갱신이 끝날 수도 있다.
> 4. `음의 사이클`(사이클에 참여하는 간선 가중치의 합이 음수인 경우)을 탐지하기 위해 `2.`의 과정을 한번 더 수행한다. 이때 `출발 노드의 최단 거리 + 간선 가중치 < 도착 노드의 최단 거리`인 케이스가 있을 경우 최단 거리를 계산하지 못한다고 판단한다(음의 사이클에 빠져 최단 거리가 `-INF`가 되기 때문).


##### SPFA (*Shortest Path Faster Algorithm*)

벨만-포드 알고리즘에서 모든 노드를 `n-1`회 순회하는 대신 바뀐 노드와 연결된 간선에 대해서만 업데이트를 진행하도록 개선한 알고리즘이다. 벨만-포드와 동일하게 음의 가중치를 가진 간선에 대응하며, 벨만-포드를 사용할 수 있는 대부분의 알고리즘에 SPFA를 적용할 수 있다.

> 1. 모든 노드의 최단 거리를 표시하는 배열을 만들고, 시작 노드는 `0`, 나머지는 `INF`로 초기화한다. 
> 2. 노드가 큐에 들어가 있는지 표시하는 배열(시작 노드는 `true`, 나머지는 `false`)과 해당 노드에서 시작된 사이클의 길이를 나타내는 배열(시작 노드는 `1`, 나머지는 `0`)도 만들어 초기화한다.
> 3. 시작 노드를 큐에 넣는다.
> 4. 큐의 맨 앞에 있는 노드를 큐에서 빼고(배열도 갱신), 해당 노드와 연결된 모든 간선에 대해 다음 과정을 수행한다.
>> 1. `출발 노드의 최단 거리 + 간선 가중치 < 도착 노드의 최단 거리`일 경우 도착 노드의 최단 거리를 `출발 노드의 최단 거리 + 간선 가중치`로 갱신한다. 출발 노드의 최단 거리가  `INF`인 경우에는 무시한다.
>> 2. 만약 `도착 노드`가 큐에 들어가지 않은 상태라면 `도착 노드`의 사이클 길이를 늘린다. 이때 사이클 길이가 전체 노드 수와 같아지면 `음의 사이클`이 있다고 판단하고 탐색을 중단한다.
>> 3. 그렇지 않다면 `도착 노드`를 큐에 넣는다(배열도 갱신).
> 5. `4.`의 과정을 큐가 빌 때까지 반복한다.

#### 플로이드-워셜 알고리즘(*Floyd-Warshall Algorithm*)

**모든 쌍 최단 경로 알고리즘(*All-pairs Shortest Path Algorithm*)** 의 일종으로, 역시 **DP**를 기반으로 한다. 위의 두 알고리즘과 달리 **모든 노드에 대한 모든 최단 경로** 를 찾는다.

> 1. 연결된 간선을 기준으로 각각의 노드가 다른 노드로 가는 거리를 정리한 2차원 배열을 만든다. `i`와 `j`가 직접적으로 연결되지 않았을 경우 `v[i][j] = INF`이고, `v[i][i] = 0`이다.
> 2. 모든 노드(`m`)와 모든 노드 쌍에 대해 `v[i][j] > v[i][m] + v[m][j]`인 경우 `v[i][j]`의 값을 `v[i][m] + v[m][j]`로 갱신한다.
