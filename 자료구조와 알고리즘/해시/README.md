## 해시 함수(*Hash Function*)

**해시 함수(*Hash Function*)** 는 **임의의 길이를 가지는 데이터를 고정 길이의 데이터로 변환하는 함수** 이다.

해시 함수의 특징은 다음과 같다.

> 1. 입력값의 길이에 관계없이 결과값의 길이는 항상 같다.
> 2. 입력값이 아주 조금 바뀌더라도 결과값은 완전히 달라진다(눈사태 효과).
> 3. 결과값으로 입력값을 유추할 수 없다.

이러한 특성을 활용해 해시 함수는 **암호화** 과정(*SHA, MD5*)에 주로 쓰이는데, 결과값이 작은 함수는 **해시 테이블** 등의 자료구조를 위해 사용된다.

## 해시 테이블(*Hash Table / HashMap*)

**해시 테이블(*Hash Table*)** 은 **키(*Key*)** 와 **값(*Value*)** 이 해시 함수를 통해 1:1로 연관되어있는 자료구조이다. 해시 테이블은 **내부적으로 키와 값을 저장하는 버킷**과 **해당 버킷의 인덱스값을 출력하는 해시 함수**로 구성되어 있는데, 이러한 특성 덕분에 탐색 시간복잡도는 배열과 마찬가지로 (해시 함수의 시간복잡도를 고려하지 않을 때) `O(1)`이 유지된다.

C++에서는 `unordered_map(hash_map)`이라는 자료구조로 제공한다. 비슷한 자료구조인 `map`은 Red-Black Tree로 구현된다.

하지만 해시 함수의 결과값은 고정 길이 값, 즉 **출력 범위가 한정** 되어 있기 때문에 다른 입력값을 넣었는데도 동일한 결과값이 나오는 **해시 충돌(*Hash Collision*)** 현상이 일어날 수 있고, 이로 인해 원치 않는 값이 출력되거나 덮어쓰여질 수 있다(비둘기 집의 원리). 이를 막는 알고리즘은 2가지가 있다.

### 개별 체이닝(Separate Chaining)

값이 저장되는 버킷을 **연결 리스트** 형식으로 만들어, 중복되는 해시값으로 새로운 값이 들어오는 경우 **원래 저장된 값 노드 뒤에 연결**하는 방식이다.

버킷의 크기 자체를 늘릴 필요가 없어 경제적이고 해시 함수가 단순해도 쉽게 구현할 수 있어 많은 곳에서 활용된다. 그러나 연결 리스트 노드를 저장하는 공간이 필요하고, 충돌이 심해지는 상황에서는 일반적인 연결 리스트처럼 탐색 복잡도가 `O(n)`으로 늘어날 수 있다는 단점이 있다.

C++, Java에서 해당 방식을 사용한다.

### 오픈 어드레싱(Open Addressing) 

값이 저장되는 버킷을 **배열** 형식으로 만들어, 중복되는 해시값이 발견될 경우, 해당 인덱스에서 **다음 비어있는 곳을 찾아 저장**(*Linear Probing*)하는 방식이다. 상황에 따라 해시값을 제곱하거나(*Quadratic Probing*), 다른 해시 함수를 적용해서(*Double Hashing*) 대체 인덱스를 찾기도 한다.

추가적인 저장 공간 없이 버킷 내에서 처리가 가능하지만, 해시 함수의 성능에 영향을 크게 받는다는 단점이 있다. 또한 수용량이 일정량을 넘어서면 성능이 기하급수적으로 하락하는데, 이를 막기 위해 일정량 채워진 경우 버킷 크기를 키워서 재배치하거나 미리 큰 버킷을 따로 만들어 기존 버킷이 비대해지면 대체하는 등의 조치를 취해야 한다. 

Python에서 해당 방식을 사용한다.
