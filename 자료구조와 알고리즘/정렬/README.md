## 정렬 알고리즘

말 그대로 배열을 정렬하는데 사용하는 알고리즘들이다. 대부분의 프로그램에서 가장 기본적으로 쓰이고, 그렇기에 알고리즘 강의에서도 항상 초반부를 담당하며, 당연히 각종 테스트에서도 단골로 등장한다. 많은 것을 알아둬서 `O(n^2)`의 수렁에 빠지지 않도록 하자.

### 선택 정렬

> '정렬되지 않은 부분'에서 가장 큰 원소를 찾아 배열 뒤쪽의 '정렬된 부분' 바로 앞쪽의 원소와 위치를 바꾼 뒤, '정렬되지 않은 부분'의 크기가 1이 될 때까지(가장 작은 원소만 남을 때까지) 이를 반복한다. ('정렬된 부분'을 앞쪽으로 둬도 된다 - 이 경우 '작은'과 '큰'을 서로 바꿔준다)

이를 코드로 나타내면 다음과 같다:

```c++
void selectionSort(vector<int>& arr){
    for (int i = arr.size() - 1; i > 0; i--){
        int max = i;                    // 가장 큰 원소가 있는 인덱스
        for (int j = 0; j < i; j++){
            if (arr[j] > arr[max])       
                max = j;                // 정렬 안 된 부분을 순회하면서 가장 큰 원소가 있는 인덱스 찾기
        }
        swap(arr[max], arr[i]);         // 정렬 안 된 부분의 가장 뒷쪽과 가장 큰 원소가 있는 곳의 원소 swap
    }
}
```

시간복잡도는 모든 경우에서 `O(n^2)`이다.

```
위치 지정을 위한 외부 루프 순회: n-1회
최댓값 탐색을 위한 내부 루프에서의 비교: n-1~1회
총 비교 횟수: (n-1)+(n-2)....+2+1 = n(n-1)/2회
swap 과정: 외부 루프 당 1회(i <-> max)
총 시간복잡도: n(n-1)/2 = n(n-1) = O(n^2)
```

### 버블 정렬

> 배열의 처음부터 끝까지 인접한 원소끼리 값을 비교해 앞의 원소가 뒤의 원소보다 큰 경우 교환한다. 이 과정이 끝나면 정렬 과정에 참여한 원소 중 마지막 원소를 제외한 나머지 원소를 대상으로 위의 과정을 반복하고, 이를 하나만 남을 때까지 반복한다.

이를 코드로 나타내면 다음과 같다:

```c++
void bubbleSort(vector<int>& arr){
    for (int i = arr.size() - 1; i > 0; i--){   // 정렬할 범위 지정
        for (int j = 0; i < i; j++)
            if (arr[j] > arr[j+1])              // 만약 나보다 내 앞이 더 작다면 교환
                swap(arr[j], arr[j+1]);
    }
}
```

시간복잡도는 모든 경우에서 `O(n^2)`이다. 그러나 정렬시키기 위해 필요한 swap 수가 한 칸씩 swap되는 특성 상 선택 정렬보다 더 많고, 때문에 **선택 정렬보다 더 오래걸린다.**

```
위치 지정을 위한 외부 루프 순회: n-1회
swap 여부를 위한 내부 루프에서의 비교: n-1~1회
총 비교 횟수: (n-1)+(n-2)....+2+1 = n(n-1)/2회
swap 과정: 최상의 경우 0번, 최악의 경우 외부 루프당 비교 횟수만큼 swap
총 시간복잡도: n(n-1)/2 = n(n-1) = O(n^2)
```

### 삽입 정렬

> 앞쪽에 정렬되어 있는 부분 바로 뒤의 원소를 선택해 앞쪽의 원소들과 비교하며 삽입할 위치를 지정한 후. 그 자리 이후의 원소들을 한 칸 뒤로 옮긴 후 그 자리에 선택한 원소를 삽입한다. 이 과정을 두 번째 원소부터 마지막 원소까지 반복한다.

이를 코드로 나타내면 다음과 같다:

```c++
void insertionSort(vector<int>& arr){
    for (int i = 1; i < arr.size(); i++){               // 두 번째 원소부터 선택
        int idx = i - 1, key = arr[i]                   // 삽입할 위치(idx), 선택한 원소를 따로 저장(key)
        for (; idx >= 0 && arr[idx] > key; idx--)       // idx가 0 이상이고 arr[idx]가 key값보다 더 클 때 한 칸 옮기고 idx--
            arr[idx + 1] = arr[idx];
        arr[idx + 1] = key;                             // 최종 확정된 곳에 key값 삽입
    }
}
```

시간복잡도는 최선의 경우(이미 정렬되어있는 경우)일 때 `O(n)`, 최악의 경우(역순으로 정렬된 경우)일 때 `O(n^2)`, 평균적으로는 `O(n^2)`이다.

```
위치 지정을 위한 외부 루프 순회: n-1회
내부 루프에서 선택한 원소와 바로 앞의 원소와의 최초 비교: 1회
이후 삽입 위치가 바뀔 때마다 이동 횟수와 비교 횟수가 1회씩 증가, 최대 n-1회까지 반복
    ((n-1)+(n-2)....+2+1 = n(n-1)/2회)
총 시간복잡도: O(n^2)
```