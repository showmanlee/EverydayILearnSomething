# 기억장치 관리

컴퓨터에는 **레지스터, 캐시 메모리, 주기억장치, 보조기억장치** 등의 기억 장치가 있다. 레지스터 쪽으로 갈수록 탐색 속도가 빠르지만, 용량이 적고 단가가 비싸다. 기억장치들은 차례로 계층 구조를 이루고 있으며, 계층이 낮아질수록 CPU에서는 멀어지지만 사용자에게는 가까워진다.

 * **레지스터**: CPU 코어 내부에 위치하며, CPU의 연산 과정에서 직접적으로 참조한다.
 * **캐시 메모리**: CPU 내 별도의 캐시 공간에 위치하며, 주기억장치와 레지스터 간 병목 현상을 완화하는 역할을 한다. 속도에 따라 L1~L3로 구분된다.
 * **주기억장치**: 흔히 RAM이라고 불리며, CPU 외부에 위치한다. 보조기억장치의 데이터를 CPU 연산에 사용하기 위해 저장하는 공간으로, CPU가 직접 데이터에 접근하기 위해서는 주기억장치에 데이터를 적재해야 한다.
 * **보조기억장치**: CPU가 직접 접근할 수 없는 기억장치로, HDD, SSD 등이 사용된다. 다른 기억장치와 달리 전원이 내려가도 데이터가 보존되고, 저장공간이 크다. 또한 다른 기억장치와 달리 사용자가 직접 접근할 수 있다.

## 기억장치 관리 전략

운영체제가 프로그램을 실행하기 위해서는 보조기억장치에서 데이터를 주기억장치에 적재해야 한다. 그리고 이를 효율적으로 하기 위한 전략은 크게 **반입, 배치, 교체** 로 나눌 수 있다.

### 반입(*Fetch*) 전략

보조기억장치에 저장된 프로그램/데이터를 *언제* 주기억장치로 적재할 것인지를 결정한다.

 * **요구 반입(*Demand Fetch*)**: 프로그램 실행 중 특정 프로그램/데이터 참조를 *요구*할 때 적재
 * **예상 반입(*Anticipatory Fetch*)**: 프로그램이 실행 중 요구할 프로그램/데이터를 미리 *예상*하여 적재

### 배치(*Placement*) 전략

새로 반입되는 프로그램/데이터를 주기억장치 *어디에* 저장할 것인지를 결정한다.

 * **최초 적합(*First Fit*)**: 프로그램/데이터가 들어갈 수 있는 빈 공간 중 *처음으로 발견된 곳*에 배치 
 * **최적 적합(*Best Fit*)**: 프로그램/데이터가 들어갈 수 있는 빈 공간 중 *가장 작은 곳*에 배치 
 * **최악 적합(*Worst Fit*)**: 프로그램/데이터가 들어갈 수 있는 빈 공간 중 *가장 큰 곳*에 배치 

세 방식은 모두 일장일단이 있어 어떤 방식이 가장 좋다고 말할 수 없다. 또한 최적/최악 적합은 주기억장치 가용공간 목록이 정렬되어 있지 않다면 주기억장치 전체를 탐색해야 한다.

### 교체(*Replacement*) 전략

주기억장치의 모든 영역이 사용 중이거나 새로운 프로그램/데이터가 들어갈 공간이 없을 때, 이미 사용되고 있는 영역 중에서 *어떤 영역을 교체*할 것인지를 결정한다.
 
 * **FIFO**(*First-In First-Out*): 주기억장치에 들어온 데이터 중 *가장 먼저 들어온(오래된)* 데이터를 교체한다. 이를 위해 데이터가 메모리에 적재된 시간을 기록하거나, 들어온 순서대로 큐에 저장할 수 있다.
 * **OPT**(*Optimal*): *앞으로* 가장 오랫동안 사용하지 않을 데이터를 교체한다. 프로세스가 앞으로 사용할 데이터가 무엇인지 미리 예측하여 최적의 성능을 발휘할 수 있지만, 현재로써는 이를 알 수 있는 방법이 없어 사용되지 않는다.
 * **LRU**(*Least-Recently-Used*): 주기억장치에 들어온 데이터 중 *가장 오래 사용되지 않은* 데이터를 교체한다. 이를 위해 데이터가 마지막으로 사용된 시간을 기록해야 한다. 실제 구현이 불가능한 OPT의 성능에 가장 근접하기에, 많은 운영체제에서 채택하고 있다.
 * **LFU**(*Least-Frequently-Used*): 주기억장치에 들어온 데이터 중 *가장 적게 사용된* 데이터를 교체한다. 만약 그런 데이터가 여러 개일 경우, LRU를 적용한다.
 * **MFU**(*Most-Frequently-Used*): 주기억장치에 들어온 데이터 중 *가장 많이 사용된* 데이터를 교체한다.
 * **NUR**(*Not-Used-Recently*): 주기억장치에 들어온 데이터 중 *참조 비트와 변형 비트*를 보고, 이에 따라 최근에 사용하지 않은 데이터를 교체한다. 참조 비트는 데이터가 호출되었을 때 1이 되고, 변형 비트는 데이터의 내용이 바뀌었을 때 1이 된다. 
 * **SCR**(*Second-Chance-Replacement*): FIFO에서 *참조 비트* 개념을 도입해, 특정 데이터에 교체 요청이 두 번 들어왔을 때 데이터를 교체한다. 데이터게 교체 요청이 한 번 들어오면 참조 비트가 0이 되고, FIFO 큐의 맨 뒤로 가게 된다.

## 주기억장치 할당

주기억장치에 프로그램/데이터를 할당하는 방법에는 두 가지가 있다.

 * **연속 할당 기법**: 프로그램을 주기억장치에 연속으로 할당하는 방법으로, **단일 분할 할당 기법**과 **다중 분할 할당 기법**이 있다.
   * **단일 분할 할당 기법**: 주기억장치를 경계 레지스터로 나뉘는 운영체제 영역과 사용자 영역으로 나누어 한 순간에는 한 명의 사용자만 사용할 수 있도록 하는 기법으로, 초기 운영체제에서 쓰였다. 
     * 오버레이 기법: 주기억장치보다 큰 프로그램을 실행하기 위한 기법으로, 보조기억장치의 프로그램을 여러 조각으로 나누어 필요한 조각을 주기억장치에 적재하여 프로그램을 실행하는 기법이다. 만약 새로운 조각을 적재해야 하는 상황에서 주기억장치의 공간이 부족하다면 불필요한 조각이 위치한 조각에 새로운 프로그램 조각을 오버레이하여 적재한다.
     * 스와핑 기법: 하나의 프로그램 전체를 주기억장치에 할당하여 필요에 따라 다른 프로그램과 스와핑하는 기법으로, 가상기억장치의 페이징 기법으로 발전되었다.
   * **다중 분할 할당 기법**
     * 고정 분할 할당(*MFT*): 현재는 사용되지 않는 기법으로, 프로그램을 할당하기 전 운영체제가 주기억장치의 사용자 영역을 여러 개의 고정된 크기로 분할한 후, 준비상태 큐에서 준비 중이 프로그램을 각 영역에 할당하여 실행하는 기법이다. 프로그램 실행을 위해서는 프로그램 전체가 주기억장치 분할 영역에 존재해야 하는데, 프로그램이 너무 크면 실행 자체가 불가능한 문제가 있다. 또한 내/외부 단편화가 발생한다(남은 공간, 못 들어가는 공간이 남음).
     * 가변 분할 할당(*MVT*): MFT의 단점을 해결하기 위해 프로그램을 주기억장치에 적재하면서 필요한 크기만큼 영역을 분할하는 기법이다. 분할 영역이 고정되어 있지 않기에 다양한 크기의 프로그램을 효율적으로 실행할 수 있으나, 여전히 내/외부 단편화가 발생할 수 있다(큰 프로그램이 분할한 공간에 작은 프로그램이 들어가는 경우, 자잘한 프로그램들이 듬성듬성 있어 큰 프로그램이 들어갈 수 없는 경우). 
 * **분산 할당 기법**: 프로그램을 조각으로 나누어 주기억장치 내에 분산하여 할당하는 방법으로, 가상기억장치와 함께 쓰인다. 페이징과 세스먼테이션 기법이 있다.