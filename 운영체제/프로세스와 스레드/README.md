# 프로세스와 스레드

## 프로세스

CPU에서 처리되는 상태인, 즉 **실행중인 프로그램** 을 말한다. 운영체제는 사용자의 명령에 따라 보조기억장치에서 실행되기를 대기하는 프로그램을 주기억장치로 적재하여 프로세스로 만든 후 실행한다. 프로세스는 다음과 같은 형태로 정의할 수 있다.

 * PCB(*Process Control Block*)를 가진 프로그램
 * 실기억장치에 저장된 프로그램
 * 프로세서가 할당되는 실체로서, *Dispatch*가 가능한 단위
 * 프로시저가 활동 중인 것
 * 비동기적 행위(다수의 프로세스가 독립적으로 실행되는 것)를 일으키는 주제
 * 지정된 결과를 얻기 위한 일련의 계통적 동작
 * 목적 또는결과에 따라 발생되는 사건들의 과정
 * 운영체제가 관리하는 실행 단위

## PCB(*Process Control Block*)

PCB는 운영체제가 프로세스를 제어하기 위해 프로세스의 정보를 저장한 구조체이다. PCB에는 다음과 같은 정보가 들어간다.

 * 프로세스 ID
 * 프로세스의 상태
 * 프로그램 카운터: 프로세스의 명령 실행을 위해 다음 명령어의 주소를 저장하는 카운터
 * 레지스터: 가산기, CPU 레지스터, 범용 레지스터 등
 * 스케줄링 정보: 우선 순위, 실행 시간, CPU 점유 시간 등
 * 메모리 정보: 프로세스의 주소 공간 정보와 그 포인터 등
 * 프로세스 정보: 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모/자식 프로세스 등
 * 입출력 정보: 프로세스에 할당된 입출력 장치 및 현황 등
 * 각종 포인터: 부모/자식 프로세스, 할당된 자원, 프로세스가 위치한 메모리 등
 * 실행 문맥: 실행 중단 후 다시 복구하기 위해 사용되는 마지막으로 실행한 프로세서의 레지스터 목록

## 메모리 구조

프로세스의 메모리 구조는 크게 ***Code, Data, Heap, Stack*** 등 4개로 나눌 수 있으며, 메모리 앞쪽부터 정렬하면 다음과 같다.

 * ***Code***: 프로그램을 실행하는 명령어들이 저장된다.
 * ***Data***: 프로그램을 실행할 때 생성되는 전역/정적 변수들이 저장된다. 초기화되지 않은 전역/정적 변수들은 BSS(*Block Stated Symbol*)라는 공간에 따로 저장된다. 프로그램을 종료하면 자동으로 반환된다.
 * ***Heap***: 동적 할당(`malloc, new`)된 변수가 저장된다. 메모리 앞쪽에서부터 아래로 내려오며, 언어에 따라 반환 함수(`free, delete`) 호출 및 가비지 컬렉터에 의해 반환된다.
 * ***Stack***: 지역 변수, 매개 변수, 함수 반환값 등 함수 내에서 일시적으로 쓰이는 지역 변수가 저장된다. 메모리 뒤쪽에서부터 위로 올라오며, 사용되는 영역(함수)가 종료되면 자동으로 반환된다.

Code, Data, BSS 영역은 컴파일 시, Heap, Stack 영역은 실행 시 크기가 결정된다. Heap과 Stack은 같은 공간을 공유하면서 위/아래부터 데이터를 저장하는데, 저장 중 서로의 영역을 침범하게 되면 `stack/heap overflow`가 되어 오류가 발생한다. 

## 상태 전이

프로세스는 아래와 같은 상태를 거치며 실행되고 종료된다.

 * **제출(*Submit*)**: 사용자가 작업을 시스템에 제출한 상태
 * **접수(*Hold*)**: `제출`된 작업이 디스크의 스풀 공간에 저장된 상태
 * **준비(*Ready*)**: `접수` 상태의 프로세스가 준비상태 큐에서 프로세서를 할당받기 위해 기다리고 있는 상태
 * **실행(*Run*)**: `준비` 상태의 프로세스가 *Dispatch*되어 프로세서를 할당받고 실행되는 상태 - 주어진 시간이 모두 소진되거나 다른 프로세스에 의해 선점 당하면 `준비` 상태로 전환된다.
 * **대기(*Blocked*)**: `실행` 상태의 프로세스가 입출력을 기다리고 있는 상태 - 입출력을 받으면 *Wake Up* 되어 `준비` 상태로 전환된다.
 * **종료(*Terminated*)**: `실행` 상태의 프로세스가 모든 실행을 마치고 할당이 해제된 상태.

기본적으로 한 코어당 한 개의 프로세스만이 `실행` 상태로 존재할 수 있다.

## 스케줄링

프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업. 시스템 자원을 모든 프로세스에 공정하게 할당하고 응답/반환 시간을 최소화해 처리량과 처리 효율을 최대한으로 하기 위해 필요하다.

스케줄링은 시점에 따라 **장기, 중기, 단기**로 나눌 수 있다.

 * 장기(작업, 상위) 스케줄링: 프로세스에게 시스템 자원을 할당하기 위해 준비상태 큐로 보내는 작업 - 작업 스케줄러
 * 중기 스케줄링: 어떤 프로세스가 CPU를 할당받을지 결정하는 작업
 * 단기(프로세서, 하위) 스케줄링: 프로세스가 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업 - 프로세서 스케줄러

### 비선점 스케줄링

비선점 스케줄링에서는 이미 할당된 자원을 다른 프로세스가 중간에 빼앗을 수 없다. 즉, 한 프로세스가 자원을 할당받으면 프로세스가 종료될 때까지 자원을 사용할 수 있음이 보장된다. 안정적이고 응답 시간 예측이 용이하나, 중요한 작업이 긴 작업에 밀려 빠르게 처리되지 못하는 등 응답 속도가 느려질 수 있다.

 * **FCFS(*First-Come First-Service*)**: 준비상태 큐에 도착한 *순서대로* 처리한다. 가장 공평한 방식이나, 중요도를 고려하지 않기 때문에 중요한 작업이 밀릴 수 있다.
 * **SJF(*Shortest-Job-First*)**: 현 시점에서 준비상태 큐에 있는 프로세스 중 *실행 시간이 가장 짧은* 프로세스부터 처리한다. 평균 대기 시간이 가장 적지만, 실행 시간이 긴 프로세스는 우선 순위가 계속 밀려 `기아 상태`가 될 수 있다.
 * **HRN(*Highest-Response-ratio Next*)**: SJF의 문제를 개선하기 위해, 우선순위를 `(대기시간 + 실행시간) / 실행시간` 으로 계산하여 처리한다. 
 * **우선순위**: 프로세스마다 우선순위를 지정해, *높은 우선순위* 를 가진 프로세스부터 처리한다. 우선순위가 낮을 수록 `기아 현상`이 일어나기 쉽다.
 * **기한부**: 프로세스에게 일정 시간을 주어 *그 시간 안에* 프로세스를 완료하게 한다. 프로세스에게 할당될 시간이 정확히 주어지지 않으면 정상적으로 프로세스가 실행되지 않는다.

`기아 현상`을 방지하기 위해 **에이징(*Aging*)** 기법을 활용, 양보되거나 일정 시간이 지날 때마다 우선순위를 순차적으로 높일 수도 있다.

### 선점 스케줄링

선점 스케줄링에서는 이미 할당된 자원을 다른 프로세스가 중간에 빼앗을 수 있다. 즉, 한 프로세스가 자원을 할당받아도 상황에 따라 자원을 빼앗기고 대기 상태로 전환될 수 있다. 비선범 스케줄링에 비해 응답 속도가 빠르지만, 오버헤드가 심하다.

 * **RR(*Round-Robin*)**: FCFS의 선점 버전으로, 준비상태 큐에 도착한 *순서대로* 실행되지만 일정 시간이 지나서도 프로세스가 완료되지 않는 경우 *다음 프로세스에게 자원이 넘어간다.* RR에서 할당된 시간이 커질 경우 FCFS와 차이가 사라지게 되며, 할당된 시간이 짧을 경우 문맥 교환이 더 자주 발생해 오버헤드가 발생하기 쉽다. 시분할 시스템에서 사용된다.
 * **SRT(*Shortest-Remaining-Time*)**: SJF의 선점 버전으로, 현재 실행 중인 프로세스의 남은 시간과 새로 들어온 프로세스의 실행 시간을 비교해 *더 짧은 쪽에게 자원이 넘어간다.*
 * **선점 우선순위**: 비선점 우선순위와 달리, 실행 중에도 *우선순위에 따라 자원이 넘어갈 수 있다.*
 * **다단계 큐**: 프로세스를 여러 개의 그룹으로 나누어 각기 다른 계층에 준비상태 큐에서 대기 프로세스를 관리한다.
 * **다단계 피드백 큐**: 다단계 큐에서 큐마다 제한 시간을 걸어 시간 초과 시 프로세스가 다음 준비상태 큐로 넘어간다. 즉, 다단계 큐에서 프로세스의 준비상태 큐 간 이동이 가능하다.

## 스레드

하나의 프로세스 내의 작업 단위로, 시스템의 자원을 할당받아 실행하는 단위이다. 하나의 프로세스에는 하나 이상의 스레드가 존재하고, 여러 개의 스레드가 있는 다중 스레드 환경에서는 프로세스의 일정 메모리 공간을 공유한다.

동시에 여러 작업을 하기 위해서는 프로세스를 여러 개 두는 것보다 스레드를 여러 개 두는 것이 더 효율적이다. 하지만 스레드는 프로세스와 달리 자원을 서로 공유하므로, 한 스레드가 공용 공간의 어떤 데이터를 조작한 것 때문에 다른 스레드의 연산 결과가 잘못 나올 수 있다. 이를 동기화 문제라고 부른다.

## 교착상태

두 개 이상의 작업이 서로 상대방의 작업이 끝나기를 기다리는 상태, 즉 서로가 서로의 작업을 대기하느라 프로그램이 멈춘 상태를 말한다.

교착상태의 발생 조건은 **상호 배제, 점유와 대기, 비선점, 순환성 대기** 등 4가지가 있으며, 여러 작업 간 4가지가 모두 충족된 상태일 때 교착상태에 빠졌다고 한다.

교착상태를 처리하기 위해서는 이런 상황이 발생하지 않도록 예방 또는 회피하거나, 교착상태를 직접 회복시키거나, 아니면 시스템적으로 교착상태가 일어나지 않도록 프로그램을 짜야 한다.

### 상호 배제(*Mutual Exclusion; Mutex*)

작업들이 공유 자원을 동시에 쓸 수 없는 경우.

모든 작업들이 공유 자원을 동시에 사용할 수 있도록 하여 이 상황을 예방할 수 있지만, 근본적으로 공유가 불가능한 자원도 분명히 있어 모든 상황에서 적용할 수는 없다.

### 점유와 대기(*Hold and Wait*)

자원을 점유한 상태에서 다른 자원을 기다리는 경우.

이 상황을 예방하기 위해서는 자원을 요구하는 상황에서 다른 자원을 점유하지 않는 것을 보장시켜야 한다. 이를 위해 프로세스가 실행되기 전 자신이 필요한 모든 자원을 할당받도록 할 수 있지만 이 경우 자원들이 낭비될 수 있고, 프로세스가 기아 상태에 빠지게 될 수도 있다. 또한 프로세스가 자원을 점유하지 않을 때만 자원을 요청할 수 있게 할 수도 있지만 이 경우 자원의 이용률이 낮아지고 비효율적이게 된다.

### 비선점(*No Preemption*)

한 프로세스가 점유하고 있는 자원을 다른 프로세스가 빼앗을 수 없는 경우.

이 상황을 예방하기 위해 자신의 자원을 강제로 다른 프로세스가 선점하게 만들 수 있다. 즉, 선점형 알고리즘을 적용하면 이 문제는 발생하지 않는다.

### 순환성 대기(*Circular Wait*)

대기 상태가 순환적으로 연결된 경우.

이 상황을 예방하기 위해 모든 자원에 순서를 부여해 프로세스 순서대로 자원을 요청하도록 강제할 수 있다.

## 세마포어(*Semaphore*)

하나의 공유되는 자원에 제한된 프로세스/스레드만 접근할 수 있게 하는 변수. 각 작업은 해당 자원에 접근 시 세마포어 값을 조정함으로서 해당 자원을 사용할 수 있는지, 그렇지 않은지를 다른 작업들에게 알려줄 수 있다. 일반적으로 세마포어 값이 0이 되면 더 이상 접근할 수 없다는 의미이다.

**뮤텍스(*Mutex*)** 는 바이너리 값을 가지는 세마포어로, 뮤텍스를 가지는 작업은 단 하나의 프로세스만 접근할 수 있고, 충돌이 일어날 경우 해당 프로세스가 책임을 진다.
