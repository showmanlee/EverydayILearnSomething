# 가상기억장치

가상기억장치는 주기억장치보다 큰 프로그램을 실행하기 위해 보조기억장치의 일부를 주기억장치처럼 사용하는 것을 말한다. 보조기억장치를 통해 주기억장치를 더 크게 사용하는 것과 같은 효과를 누릴 수 있고, 주기억장치의 이용률과 다중 프로그래밍의 효율을 늘릴 수 있다.

프로그램을 여러 개의 **블록** 단위로 나눈 후 가상기억장치에 저장하고, 가상기억장치에서 필요한 블록만 주기억장치에 할당하여 사용한다. **블록**을 나누는 방법으로는 **페이징** 기법과 **세그먼테이션** 기법이 있으며, 현대 운영체제는 두 가지 방법을 모두 활용하고 있다(주로 세그먼트로 먼저 나눈 후, 그 공간을 페이징하는 방식을 사용된다).

## 페이징(*Paging*)

프로그램을 고정된 크기의 **페이지**로 나누어 사용하는 기법이다. 이때 페이지의 크기에 맞게 주기억장치도 여러 공간으로 나누게 되는데, 프로그램을 나눈 단위를 **페이지**, 페이지 크기로 나누어진 주기억장치의 단위를 **프레임**으로 부른다.

주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요하다. 각 프레임의 주소는 `r = p' + d`로 나타낼 수 있으며(r = 물리 주소, p` = 프레임 번호, d = 오프셋), 페이지 맵 테이블이라는 별도의 테이블에 저장된다.

**페이지의 크기가 클 경우** 페이지 맵 테이블 크기가 작아지고 매핑 속도가 빨라져 입출력 효율이 높아지지만, 내부 단편화가 증가하고 페이지를 주기억장치로 이동하는 시간이 늘어난다. 또한 큰 페이지 안에 들어간 불필요한 데이터까지 함께 적재될 수 있다. 반대로 **페이지의 크기가 작을 경우** 불필요한 데이터가 적재될 확률이 줄어들고 단편화도 줄어들어 기억장치 효율이 좋아지지만, 페이지 맵 테이블 크기가 커지고 매핑 속도가 느려져 입출력 효율이 낮아진다.

페이지의 최대 크기가 고정되어 있기 때문에 외부 단편화가 발생하지 않지만, 페이지 크기보다 작은 페이지가 들어왔을 시 **내부 단편화가 발생할 수 있다.**

### 페이지 교체 알고리즘

CPU가 액세스한 페이지가 주기억장치에 없는 상황인 페이지 부재(*Page Fault*)가 발생했을 때 새로운 페이지를 주기억장치에 저장하는 기법이다.

 * **FIFO**(*First-In First-Out*): 주기억장치에 들어온 페이지 중 *가장 먼저 들어온(오래된)* 페이지를 교체한다. 이를 위해 페이지가 메모리에 적재된 시간을 기록하거나, 들어온 순서대로 큐에 저장할 수 있다.
 * **OPT**(*Optimal*): *앞으로* 가장 오랫동안 사용하지 않을 페이지를 교체한다. 앞으로 사용할 페이지가 무엇인지 미리 예측하여 최적의 성능을 발휘할 수 있지만, 현재로써는 이를 알 수 있는 방법이 없어 사용되지 않는다.
 * **LRU**(*Least-Recently-Used*): 주기억장치에 들어온 페이지 중 *가장 오래 사용되지 않은* 페이지를 교체한다. 이를 위해 페이지가 마지막으로 사용된 시간을 기록해야 한다. 실제 구현이 불가능한 OPT의 성능에 가장 근접하기에, 많은 운영체제에서 채택하고 있다.
 * **LFU**(*Least-Frequently-Used*): 주기억장치에 들어온 페이지 중 *가장 적게 사용된* 페이지를 교체한다. 만약 그런 페이지가 여러 개일 경우, LRU를 적용한다.
 * **MFU**(*Most-Frequently-Used*): 주기억장치에 들어온 페이지 중 *가장 많이 사용된* 페이지를 교체한다.
 * **NUR**(*Not-Used-Recently*): 주기억장치에 들어온 페이지 중 *참조 비트와 변형 비트*를 보고, 이에 따라 최근에 사용하지 않은 페이지를 교체한다. 참조 비트는 페이지가 호출되었을 때 1이 되고, 변형 비트는 페이지의 내용이 바뀌었을 때 1이 된다. 
 * **SCR**(*Second-Chance-Replacement*): FIFO에서 *참조 비트* 개념을 도입해, 특정 페이지에 교체 요청이 두 번 들어왔을 때 페이지를 교체한다. 페이지에 교체 요청이 한 번 들어오면 참조 비트가 0이 되고, FIFO 큐의 맨 뒤로 가게 된다.

## 세그먼테이션(*Segmentation*)

프로그램을 크기가 서로 다른 **세그먼트**로 분할하여 사용하는 기법이다. 기억장치의 사용자 관점을 보존하고, 기억 공간을 효율적으로 사용하기 위해 사용한다.

페이징 기법과 달리 블록의 크기가 서로 다르기 때문에 주기억장치를 미리 분할할 수 없어 매 적재마다 빈 공간을 찾아야 한다. 각 세그먼트의 주소는 세그먼트 맵 테이블이라는 별도의 테이블에 저장된다.

세그먼트의 크기가 모두 다르기 때문에 내부 단편화가 발생하지 않지만, 너무 큰 세그먼트가 들어오면 **외부 단편화가 발생할 수 있다.**

## 유의사항

### 구역성(*Locality*)

프로세스가 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론으로, 워킹 셋 등 가상기억장치 관리 이론들에 영향을 주었다.

 * **시간 구역성(*Temporal Locality*)**: 하나의 페이지를 *일정 시간* 동안 집중적으로 액세스하는 현상. 루프, 스택, 서브루틴, 카운팅, 집계 등에 사용되는 변수에서 주로 발생한다.
 * **공간 구역성(*Spatial Locality*)**: *일정 위치* 의 페이지를 집중적으로 액세스하는 현상. 배열 순회, 순차적 코드 실행, 주변에 선언된 변수를 접근할 때 주로 발생한다.

### 스래싱(*Thrashing*)

프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상으로, 프로세스 실행 중 자주 페이지 부재가 발생함으로써 나타난다.

스래싱이 발생하면 CPU의 이용률이 급격히 감소하여 시스템의 심각한 성능 저하를 초래한다. 따라서 워킹 셋을 유지하거나 PFF를 조절하는 등 다중 프로그래밍의 정도를 적정 수준으로 유지할 필요가 있다.

### 워킹 셋(*Working Set*)

프로세스가 일정 시간동안 참조하는 페이지의 집합. 워킹 셋 안에 있는 페이지는 현재 프로세스가 자주 쓰는 페이지로, 이들을 주기억장치에서 교체되지 않도록 유지시키면 스래싱으로 인한 성능 저하를 막을 수 있다.

실행 시점에 따라 프로세스가 요구하는 페이지도 달라지는 만큼, 워킹 셋도 지속적으로 바뀐다.

### 페이지 부재 빈도(*Page Fault Frequency; PFF*)

페이지 부재가 일어나는 횟수로, 이 수치를 이용해 페이지 부재율을 적정 수준으로 유지할 수 있다. 즉, 페이지 부재율이 늘어나면 버리는 페이지의 수를 늘려 더 많은 페이지를 할당하고, 페이지 부재율이 줄어들면 줄이는 것이다.

또한 과도한 페이지 부재를 막기 위해 **프리페이징(*Prepaging*)** 기법으로 필요할 것 같은 모든 페이지를 처음에 한꺼번에 적재할 수도 있다. 다만 이 경우 초기 로딩 속도가 느려지고, 적재된 페이지 중 필요하지 않은 페이지가 있을 수도 있다.